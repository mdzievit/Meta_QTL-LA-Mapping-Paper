as.data.frame() %>%
mutate(Check = 1) %>%
gather(Genotype,Pass,-Range,-Check) %>%
mutate(Row_Block = ifelse(Pass %% 4 != 0,
Pass %/% 4 + 1,
Pass %/% 4)) %>%
right_join(all_field %>%
select(-Genotype),
by = c("Pass","Range","Row_Block"))
row_block_tally <- field_layout_formatted %>%
na.omit() %>%
group_by(Row_Block,Genotype) %>%
summarise(Total = sum(Check, na.rm = TRUE)) %>%
ungroup() %>%
mutate(Final = 1) %>%
summarise(Final_Tally = sum(Final)) %>%
pull(Final_Tally)
print(row_block_tally)
}
return(field_layout)
}
field_design <- function(field_length, field_width, number_lines, number_checks) {
field_length <- field_length
field_width <- field_width
number_lines <- number_lines
number_checks <- number_checks
row_block_tally <- 0
pass <- (field_width / 4 * number_checks)
while(row_block_tally != pass) {
field_layout <- NULL
for(i in 1:field_length) {
field_layout <- rbind(field_layout,
c(i,sample(1:field_width,
number_checks,
replace = FALSE)))
}
colnames(field_layout) <- c("Range","B73","PHW30","Mo17")
all_field <- field_layout %>%
as.data.frame() %>%
gather(Genotype,Pass,-Range) %>%
complete(Pass = full_seq(c(1:(field_width)), 1),
Range = full_seq(c(1: field_length),1)) %>%
mutate(Row_Block = ifelse(Pass %% 4 != 0,
Pass %/% 4 + 1,
Pass %/% 4))
field_layout_formatted <- field_layout %>%
as.data.frame() %>%
mutate(Check = 1) %>%
gather(Genotype,Pass,-Range,-Check) %>%
mutate(Row_Block = ifelse(Pass %% 4 != 0,
Pass %/% 4 + 1,
Pass %/% 4)) %>%
right_join(all_field %>%
select(-Genotype),
by = c("Pass","Range","Row_Block"))
row_block_tally <- field_layout_formatted %>%
na.omit() %>%
group_by(Row_Block,Genotype) %>%
summarise(Total = sum(Check, na.rm = TRUE)) %>%
ungroup() %>%
mutate(Final = 1) %>%
summarise(Final_Tally = sum(Final)) %>%
pull(Final_Tally)
}
return(field_layout)
}
check_design <- field_design(field_length = field_length,
field_width = field_width,
number_lines = number_lines,
number_checks = number_checks)
d <- data.frame(x1=rnorm(10),
x2=rnorm(10),
x3=rnorm(10))
d_cor <- as.matrix(cor(d))
d_cor_melt <- arrange(melt(d_cor), -abs(value))
d <- data.frame(x1=rnorm(10),
x2=rnorm(10),
x3=rnorm(10))
d <- data.frame(x1=rnorm(10),
x2=rnorm(10),
x3=rnorm(10))
View(d)
cor(d)
d_cor <- as.matrix(cor(d))
d_cor_melt <- arrange(melt(d_cor), -abs(value))
library(tidyverse)
library(reshape2)
d_cor_melt <- arrange(melt(d_cor), -abs(value))
View(d_cor_melt)
View(d_cor_melt)
library(tidyverse)
orange.df = Orange
orange.df$Tree = factor(as.numeric(orange.df$Tree))
orange.mod1 = lm(circumference ~ age, data = orange.df)
summary(orange.mod1)
orange.mod2 = lm(circumference ~ age + Tree, data = orange.df)
summary(orange.mod2)
anova(orange.mod1,orange.mod2)
View(orange.df)
orange.mod3 = lm(circumference ~ age + Tree + age:Tree, data = orange.df)
summary(orange.mod3)
anova(orange.mod2, orange.mod3)
lm(circumference ~ age:Tree, data = orange.df)
orange.mod3 = summary(lm(circumference ~ age:Tree, data = orange.df))
summary(lm(circumference ~ age:Tree, data = orange.df))
install.packages("gganimate")
install.packages("gganimate")
library(gganimate)
knitr::opts_chunk$set(message = FALSE, warning = FALSE, fig.show = "animate")
library(gganimate)
devtools::install_github("dgrtwo/gganimate")
install.packages("devtools")
install.packages("devtools")
library(rrBLUP)
#random population of 200 lines with 1000 markers
M <- matrix(rep(0,200*1000),200,1000)
View(M)
head(M)[1:5,1:5]
for (i in 1:200) {
M[i,] <- ifelse(runif(1000)<0.5,-1,1)
}
head(M)[1:5,1:5]
rownames(M) <- 1:200
A <- A.mat(M)
#random phenotypes
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
#random phenotypes
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
head(data)[1:5,1:5]
head(data)[1:5,1:2
]
head(A)[1:5,1:5]
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A)
accuracy <- cor(g,ans$g)
ans$g
ans$g[1:10]
ans$g[1:10]
#random phenotypes
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data.frame(y = y, gid = 1:200))
c(rep(1,200),rep(2,200))
data$Env <- c(rep(1,200),rep(2,200))
#random phenotypes
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
#random phenotypes
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A, fixed = c("Env"))
accuracy <- cor(g,ans$g)
ans$g
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.6 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A, fixed = c("Env"))
accuracy <- cor(g,ans$g)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.6 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A, fixed = c("Env"))
accuracy <- cor(g,ans$g)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.6 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A, fixed = c("Env"))
accuracy <- cor(g,ans$g)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.6 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A, fixed = c("Env"))
accuracy <- cor(g,ans$g)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.6 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A, fixed = c("Env"))
accuracy <- cor(g,ans$g)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.6 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A, fixed = c("Env"))
accuracy <- cor(g,ans$g)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.5 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- data.frame(y=y,gid=1:200)
u <- rnorm(1000)
g <- as.vector(crossprod(t(M),u))
h2 <- 0.6 #heritability
y <- g + rnorm(200,mean=0,sd=sqrt((1-h2)/h2*var(g)))
data <- rbind(data,data.frame(y = y, gid = 1:200))
data$Env <- c(rep(1,200),rep(2,200))
#predict breeding values
ans <- kin.blup(data=data,geno="gid",pheno="y",K=A, fixed = c("Env"))
accuracy <- cor(g,ans$g)
N <- 10^6
X <- rchisq(N, 3)
w <- dexp(X, 1) / dchisq(X, 3)
Y <- log(1+X)*w #h(x)*w(x)
N <- 10^3
X <- rchisq(N, 3)
w <- dexp(X, 1) / dchisq(X, 3)
Y <- log(1+X)*w #h(x)*w(x)
mean(Y)
sd(Y)/sqrt(N)
c(mean(Y)-2*sd(Y)/sqrt(N),
mean(Y)+2*sd(Y)/sqrt(N))
Xe <- rexp(N, 1/2)
we <- dexp(Xe, 1) / dexp(Xe, 1/2)
Ye <- log(1+Xe)*we
mean(Ye)
sd(Ye)/sqrt(N)
c(mean(Ye)-2*sd(Ye)/sqrt(N),
mean(Ye)+2*sd(Ye)/sqrt(N))
library(tidyverse)
tidy <- as_tibble(cbind(X, Xe, Y, Ye))
View(tidy)
Xtib <- as_tibble(cbind(X, Xe)) %>%
gather(Xs, Xvalue)
View(Xtib)
Ytib <- as_tibble(cbind(Y, Ye)) %>%
gather(Ys, Yvalue)
View(Xtib)
View(Ytib)
as_tibble(cbind(Y, Ye))
View(Ytib)
Alltib <- cbind(Xtib, Ytib)
View(Alltib)
ggplot(Alltib, aes(x=Xvalue, y=Yvalue, col = Xs)) +
geom_point()
View(Alltib)
citation()
install.packages("gridExtra")
library(sensitivitymv)
library(tidyverse)
library(survcomp)
library(grid)
library(gridExtra)
##Analysis done with RefGen V3
print(sessionInfo())
######Determine Total Genomic Bins in genome #######
##Sets the genomic bin size for the meta-analysis
####And sets the value to convert LRT to chi sq and the number of df used to
####convert to p-values
bins <- 10000000
two_loge10 <- (2*log(10))
df <- 1
##Reads in the chr lengths and calculates total bins per chr
chrLengths <- read_tsv("RefGenV3_Chr_Lengths.txt") %>%
mutate(Bins = (Length %/% bins) + 1)
##Calculates the total number of genomic bins for the genome and reports it back
totalBinNum <- chrLengths %>%
summarise(Total = sum(Bins)) %>%
pull(Total)
library(sensitivitymv)
library(tidyverse)
library(survcomp)
library(grid)
library(gridExtra)
##Analysis done with RefGen V3
print(sessionInfo())
######Determine Total Genomic Bins in genome #######
##Sets the genomic bin size for the meta-analysis
####And sets the value to convert LRT to chi sq and the number of df used to
####convert to p-values
bins <- 10000000
two_loge10 <- (2*log(10))
df <- 1
##Reads in the chr lengths and calculates total bins per chr
chrLengths <- read_tsv("RefGenV3_Chr_Lengths.txt") %>%
mutate(Bins = (Length %/% bins) + 1)
setwd("C:/Users/mdzievit.IASTATE/Box Sync/Manuscripts/MLA-QTL_Mapping/Meta_QTL-LA-Mapping-Paper/4.Meta-Analysis_code_and_files")
##Reads in the chr lengths and calculates total bins per chr
chrLengths <- read_tsv("RefGenV3_Chr_Lengths.txt") %>%
mutate(Bins = (Length %/% bins) + 1)
##Calculates the total number of genomic bins for the genome and reports it back
totalBinNum <- chrLengths %>%
summarise(Total = sum(Bins)) %>%
pull(Total)
##This expands out the total possible bins so I can get a row_order for
##all the bins. This allows me to plot them in physical position
##on the x-axis. I also added an extra bin to the end of each chromosome
##This is purely for plotting purposes so I can have the dotted gray line separate chromosomes
##and not overlap with a bin that might be at the end of a chromosome.
total_bins <- data.frame(Chr = numeric(0),
Bin = numeric(0))
bin_num <- chrLengths %>%
pull(Bins)
for (i in 1:10) {
for (j in 1:(bin_num[i] + 1)) {
total_bins <- total_bins %>%
add_row(Chr = i,
Bin = j)
}
}
############Run the meta-analysis ########
##Reads the QTL information
data <- read_delim("snps_pvalues_final_version.txt",
delim = "\t")
####Assigns the QTL to a genomic bin and ranks the p_value by QTL study and
####canopy level the QTL was detected in so we can remove redundant QTLs
data_bin <- data %>%
arrange(Chr,Start,End) %>%
mutate(Midpoint = (Start + End)/2,
Bin = (Midpoint %/% bins) + 1,
p_value = case_when(
!is.na(LOD) & is.na(p_value) ~ dchisq((LOD * two_loge10),df),
!is.na(LRT) & is.na(p_value) ~ dchisq(LRT,df),
TRUE ~ p_value)) %>%
arrange(Chr,Midpoint) %>%
ungroup() %>%
group_by(SourceID,Chr,Bin) %>%
mutate(pvalue_rank = rank(p_value, ties.method = "first")) %>%
ungroup() %>%
arrange(SourceID,Chr,Bin) %>%
select(-LRT,-LOD)
##This filters the data and pulls the top ranked QTL for each group set before
data_bin_filtered <- data_bin %>%
filter(pvalue_rank == 1)
##Report the number of QTL detected from QTL and Joint LInkage mapping
(total_QTL <- data_bin %>%
filter(Method %in% c("QTL_Mapping","Joint_Linkage")) %>%
summarise(n = n()) %>%
pull(n))
##Report the number of non-redudant QTL detected
(nonRed_QTL <- dim(data_bin_filtered)[1])
##Report as percentage
nonRed_QTL / total_QTL
#Summarizes how many bins all the unique QTL map into
number_per_bin <- data_bin %>%
filter(pvalue_rank == 1) %>%
group_by(Chr,Bin) %>%
summarise(n = n())
##How many bins do all the QTL map into
dim(number_per_bin)[1]
##Calculation of threshold p-value/LOD score
##Starting value was LOD 3.0 per Lander and Botstein, LOD 3 equates to alpha 0.05,
##so we doubled that to reduce false positives
##Then we divided by the number of bins we are testing (Bonferronni Correction)
##Converts LOD score (3.0 x 2) to a p-value to adjust for Bonferroni
cutoff <- ((pchisq((two_loge10 * 3.0),1,lower.tail = FALSE) / 2) *
(pchisq((two_loge10 * 3.0),1,lower.tail = FALSE) / 2)) /
dim(data_bin_filtered %>%
select(Chr,Bin) %>%
unique())[1]
##This converts the calculated p-value threshold back to a LOD score
lod_cutoff <- (qchisq(cutoff,1,lower.tail = FALSE,log.p = FALSE)) / two_loge10
##Read the candidate gene information and assign them to bins
candGenes <- read_delim("Candidate_Genes_v3.txt",
delim = "\t")
candGenes <- candGenes %>%
mutate(Midpoint = (Start + End)/2,
SourceID = "Cand") %>%
group_by(Chr) %>%
mutate(Bin = (Midpoint %/% bins) + 1)
##This runs the grouped_pvale as described in the paper
data_bin_pvalue_z <- data_bin %>%
filter(pvalue_rank == 1) %>%
#Method == "QTL_Mapping") %>%
group_by(Chr,Bin) %>%
summarise(Grouped_pvalue = combine.test(p = p_value, w = sample_size, method = "logit",
hetero = FALSE, na.rm = TRUE),
n = n()) %>%
mutate(Passed = Grouped_pvalue < cutoff,
Bin_Start = ((Bin-1)*bins/1000000),
Bin_End = (Bin * bins)/1000000) %>%
ungroup() %>%
mutate(Rnk = rank(Grouped_pvalue, ties.method = "first"),
Top_15 = ifelse(Rnk <= 15, "Yes","No"))
##This joins the bins with candidate genes and then simply says whether there is a candidate
##gene present in the bin. It is used for plotting purposes
candGenes_formatted_z <- data_bin_pvalue_z %>%
select(Chr,Bin,Grouped_pvalue,Rnk,Passed) %>%
#filter(Passed) %>%
left_join(candGenes, by = c("Chr","Bin")) %>%
select(Chr,Bin,Maize_Gene_Name) %>%
group_by(Chr,Bin) %>%
mutate(Present = ifelse(!is.na(Maize_Gene_Name),1,0)) %>%
summarise(Cand_Gene_Present = ifelse(sum(Present == 0),"No","Yes"))
##This reports the number of candidate genes detected in all significant bins
data_bin_pvalue_z %>%
select(Chr,Bin,Grouped_pvalue,Rnk,Passed) %>%
filter(Passed) %>%
left_join(candGenes, by = c("Chr","Bin")) %>%
select(Chr,Bin,Maize_Gene_Name) %>%
group_by(Chr,Bin) %>%
mutate(Present = ifelse(!is.na(Maize_Gene_Name),1,0)) %>%
summarise(Cand_Gene_Present = ifelse(sum(Present == 0),"No","Yes")) %>%
filter(Cand_Gene_Present == "Yes") %>%
ungroup() %>%
summarise(Total = n()) %>%
pull(Total)
##This reports all candidate genes identified in a significant bin
##along with all QTL identified. This is what was used to make supplemental table 4
total_summary <- data_bin_pvalue_z %>%
filter(Passed) %>%
select(Chr,Bin,Grouped_pvalue,Rnk) %>%
left_join(candGenes %>%
select(Gene,Maize_Gene_Name, Chr,Bin,Species),
by = c("Chr","Bin")) %>%
left_join(data_bin %>%
select(QTLID,SourceID,Chr,Bin,Canopy_Level),
by = c("Chr","Bin")) %>%
arrange(Rnk,QTLID)
##Read the candidate gene information and assign them to bins
candGenes <- read_delim("Candidate_Genes_v3.txt",
delim = "\t")
candGenes <- candGenes %>%
mutate(Midpoint = (Start + End)/2,
SourceID = "Cand") %>%
group_by(Chr) %>%
mutate(Bin = (Midpoint %/% bins) + 1)
##This runs the grouped_pvale as described in the paper
data_bin_pvalue_z <- data_bin %>%
filter(pvalue_rank == 1) %>%
#Method == "QTL_Mapping") %>%
group_by(Chr,Bin) %>%
summarise(Grouped_pvalue = combine.test(p = p_value, w = sample_size, method = "logit",
hetero = FALSE, na.rm = TRUE),
n = n()) %>%
mutate(Passed = Grouped_pvalue < cutoff,
Bin_Start = ((Bin-1)*bins/1000000),
Bin_End = (Bin * bins)/1000000) %>%
ungroup() %>%
mutate(Rnk = rank(Grouped_pvalue, ties.method = "first"),
Top_15 = ifelse(Rnk <= 15, "Yes","No"))
install.packages("survcomp")
